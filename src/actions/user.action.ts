"use server";

import prisma from "@/lib/prisma";
import { auth, currentUser } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";

export async function syncUser() {
  try {
    const { userId } = await auth(); // the "userId" is from clerk, it is generated automatically for the user
    const user = await currentUser(); // by clerk when a user is logged in. currentUser gets all information about
    if (!userId || !user) return; // the user from the provider which is google or email in this case.

    // check if user exists
    const existingUser = await prisma.user.findUnique({
      where: {
        clerkId: userId,
      },
    });
    // this means go into user database and find the clerkId which is equals to the userId to confirm if there is an existing user. it must have @unique identifier in the schema.prisma. Then existinUser is assigned assined the users information.

    if (existingUser) return existingUser;

    const dbUser = await prisma.user.create({
      // this means go into the user database and create this data
      data: {
        clerkId: userId,
        name: `${user.firstName || ""} ${user.lastName || ""}`,
        username:
          user.username ?? user.emailAddresses[0].emailAddress.split("@")[0],
        email: user.emailAddresses[0].emailAddress,
        image: user.imageUrl,
      },
    });
    return dbUser;
  } catch (error) {
    console.log("Error in syncUser", error);
  }
}

export async function getUserByClerkId(clerkId: string) {
  // authUser.id was passed as the parameter since the userId value which was asssigned as the clerkId value is the same as the id that is generated for the user when clerk gets the users information fo the provider. so userId from auth is the same as the id clerk generates for the user. So this is fine. It says go into the user database find the user id that is equals to clerkId.
  return prisma.user.findUnique({
    where: {
      clerkId, // find the user whose clerkId is equals to the id from clerk since they are the same. It selects
    }, // all the propeties except the relations.
    include: {
      // include the relations that are selected.
      _count: {
        // Find the number of that which is selected.
        select: {
          // selected relations.
          followers: true,
          following: true,
          posts: true,
        },
      },
    },
  });
}

export async function getDbUserId() {
  const { userId: clerkId } = await auth(); // from clerk

  if (!clerkId) return null;

  const user = await getUserByClerkId(clerkId);

  if (!user) throw new Error("User not found");

  return user.id; // this is the id generated by neon not the clerkId.The user here is from the database.
}

export async function getRandomUsers() {
  try {
    const userId = await getDbUserId(); // id by neon in the database

    if (!userId) return [];

    // get 3 random users exclude ourselves & users that we already follow
    const randomUsers = await prisma.user.findMany({
      where: {
        AND: [
          //We used AND since there are two things we wants to do, exclude and select.
          { NOT: { id: userId } }, // exclude the user himself.
          {
            NOT: {
              // we could have also used none.
              followers: {
                some: {
                  // checks if at least one follower exists where followerId is equal to userId.
                  followerId: userId, //* exclude those he already follows.
                },
              },
            },
          },
        ],
      },
      select: {
        // so now after excluding those users, select these properties from the ramaining users
        id: true,
        name: true,
        username: true,
        image: true,
        _count: {
          select: {
            followers: true, //number of followers a user has.
          },
        },
      },
      take: 3, // take 3 random users
    });

    return randomUsers; // it returns what was selected
  } catch (error) {
    console.log("Error fetching random users", error);
    return [];
  }
}

export async function toggleFollow(targetUserId: string) {
  try {
    const userId = await getDbUserId(); // id of the user that wants to follow. That is the user himself from db.

    if (userId === targetUserId) throw new Error("You cannot follow yourself");

    if (!userId) return;

    const existingFollow = await prisma.follows.findUnique({
      where: {
        followerId_followingId: {
          followerId: userId,
          followingId: targetUserId,
        },
      },
    });

    if (existingFollow) {
      await prisma.follows.delete({
        where: {
          followerId_followingId: {
            followerId: userId,
            followingId: targetUserId,
          },
        },
      });
    } else {
      await prisma.$transaction([
        prisma.follows.create({
          data: {
            followerId: userId, // user following
            followingId: targetUserId, // user being followed
          },
        }),
        prisma.notification.create({
          data: {
            type: "FOLLOW",
            userId: targetUserId, // user being followed id
            creatorId: userId, // user following id
          },
        }),
      ]);
      revalidatePath("/");

      return { success: true };
    }
  } catch (error) {
    console.log("Error in toggleFollow, error");
    return { success: false, error: "Error toggling follow" };
  }
}
